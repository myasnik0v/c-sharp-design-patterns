
# Декоратор

## Определение
Cтруктурный паттерн проектирования, который позволяет динамически добавлять объектам новую функциональность

## Структура
![](https://refactoring.guru/images/patterns/diagrams/decorator/structure.png)

## Применимость
- нужно расширить поведение без изменения существующих объектов
- нужен способ комбинировать поведение объектов, который не приведет в большому количеству новых классов на верхних уровнях иерархии

## Шаги реализации
1. убедитесь, что в вашей задаче есть один основной компонент и несколько опциональных дополнений или надстроек над ним
2. создайте интерфейс компонента, который описывал бы общие методы как для основного компонента, так и для его дополнений
3. создайте класс конкретного компонента и поместите в него основную бизнес-логику
4. создайте базовый класс декораторов. Он должен иметь поле для хранения ссылки на вложенный объект-компонент. Все методы базового декоратора должны делегировать действие вложенному объекту
5. и конкретный компонент, и базовый декоратор должны следовать одному и тому же интерфейсу компонента
6. теперь создайте классы конкретных декораторов, наследуя их от базового декоратора. Конкретный декоратор должен выполнять свою добавочную функцию, а затем (или перед этим) вызывать эту же операцию обёрнутого объекта
7. клиент берёт на себя ответственность за конфигурацию и порядок обёртывания объектов.

## Преимущества:
- наследование в паттерне используется для согласования типов, а не обеспечения поведения
- использование композиции дает большую гибкость - субклассирование задается статически, на стадии компиляции, поведение наследуется всеми потомками, не разрешает наследовать поведение нескольких классов одновременно
- позволяет добавлять функциональность динамически с помощью написания нового кода, вместо изменения существующего
- можно добавлять несколько новых обязанностей сразу, т.к компонент можно оборачивать в произвольное количество декораторов
- позволяет иметь несколько мелких объектов вместо одного на все случаи жизни

## Недостатки:
- трудно конфигурировать многократно обёрнутые объекты
- обилие крошечных классов

## Согласованность с принципами проектирования:
- полезен для соблюдения Принципа Единственной Ответственности, поскольку позволяет разделить функциональные возможности между классами
- классы должны быть открыты для расширения и закрыты для изменения